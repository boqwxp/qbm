/*****************************************************************************
 * This file is part of the QBM (Quantified Binary Matching) program.
 *
 * Copyright (C) 2016
 *      Thomas B. Preusser <thomas.preusser@utexas.edu>
 *****************************************************************************
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 ****************************************************************************/
#include "Root.hpp"
#include "Context.hpp"

#include "Quantor.hpp"

#include <iostream>
#include <sstream>
#include <algorithm>

Root::Root(CompDecl const &decl, std::vector<int> const &generics)
  : m_top(""),
    m_confignxt(FIRST_CONFIG),
    m_inputnxt (FIRST_INPUT),
    m_signalnxt(FIRST_SIGNAL) {

  std::map<std::string, int>  params;
  { // Compute Generic Parameters
    unsigned const  n = generics.size();
    if(n != decl.countParameters())  throw "Wrong number of parameters.";
    for(unsigned  i = 0; i < n; i++)  params[decl.getParameter(i).name()] = generics[i];
  }

  Context  ctx(*this, m_top, std::move(params));
  decl.forAllPorts([this, &ctx](PortDecl const &decl) {
      int const  width = ctx.computeConstant(decl.width());
      ctx.registerSignal(decl.name(), decl.direction() == PortDecl::Direction::in? allocateInput(width) : allocateSignal(width));
    });
  ctx.compile("<top>", decl);
}

Bus Root::allocateConfig(unsigned  width) {
  Node *const  nodes = new Node[width];
  for(unsigned  i = 0; i < width; i++) {
    nodes[i] = m_confignxt++;
  }
  return  Bus(width, nodes);
}

Bus Root::allocateInput (unsigned  width) {
  Node *const  nodes = new Node[width];
  for(unsigned  i = 0; i < width; i++) {
    nodes[i] = m_inputnxt++;
  }
  return  Bus(width, nodes);
}

Bus Root::allocateSignal(unsigned  width) {
  Node *const  nodes = new Node[width];
  for(unsigned  i = 0; i < width; i++) {
    nodes[i] = m_signalnxt++;
  }
  return  Bus(width, nodes);
}

namespace {
  class Lit {
    int  m_val;
  public:
    Lit(int  val) : m_val(val) {}
    ~Lit() {}
  public:
    operator int() const { return  m_val; }
    operator int&()      { return  m_val; }
  };
  std::ostream& operator<<(std::ostream& out, Lit  lit) {
    int   v = static_cast<int>(lit);
    char  c = 'X'; // this should not stick!
    if(v < 0) {
      out << '~';
      v = -v;
    }

    if(v >= Root::FIRST_SIGNAL) {
      c = 'n';
      v -= Root::FIRST_SIGNAL;
    }
    else if(v >= Root::FIRST_INPUT) {
      c = 'i';
      v -= Root::FIRST_INPUT;
    }
    else if(v >= Root::FIRST_CONFIG) {
      c = 'c';
      v -= Root::FIRST_CONFIG;
    }
    return  out << c << v;
  }
}

void Root::print(std::ostream &out, Bus const &bus) const {
  for(unsigned  i = bus.width(); i-- > 0;)  out << Lit(bus[i]) << ' ';
  out << std::endl;
}

void Root::addClause(int const *beg, int const *end) {
  auto const  size = m_clauses.size();
  while(beg < end) {
    int const v = *beg++;
    switch(v) {
    default:
      m_clauses.push_back(v);
    case Node::BOT:
      continue;
    case Node::TOP:
      // Rollback to remove already satisfied clause
      m_clauses.resize(size);
      return;
    }
  }
  m_clauses.push_back(0);
}

void Root::dumpClauses(std::ostream &out) const {
  for(int  v : m_clauses) {
    if(v == 0)  out << std::endl;
    else  out << Lit(v) << ' ';
  }
}

std::function<int(int)> Root::varCompactor() const {
  // Compute displacements to compact range of variables
  int const  delta_input  =  FIRST_INPUT  - m_confignxt;
  int const  delta_signal = (FIRST_SIGNAL - m_inputnxt) + delta_input;
  return  [delta_input, delta_signal](int const  v) -> int {
    int  vv = std::abs(v);
    if(vv >= FIRST_SIGNAL)      vv -= delta_signal;
    else if(vv >= FIRST_INPUT)  vv -= delta_input;
    vv--; // use the space of TOP & BOT
    return  v < 0? -vv : vv;
  };
}

void Root::dumpQDimacs(std::ostream &out) const {
  auto const  compact = varCompactor();

  // Ouput Header
  out <<
    "c Generated by QBM [https://github.com/preusser/qbm]\n"
    "c   by Thomas B. Preusser <thomas.preusser@utexas.edu>\n"
    "p cnf " << compact(m_signalnxt-1) << ' ' << std::count(m_clauses.begin(), m_clauses.end(), 0) << std::endl;

  // Existential: Configuration
  out << "e ";
  for(int  i = FIRST_CONFIG; i < m_confignxt; i++)  out << compact(i) << ' ';
  out << '0' << std::endl;

  // Universal: Inputs
  out << "a ";
  for(int  i = FIRST_INPUT; i < m_inputnxt; i++)  out << compact(i) << ' ';
  out << '0' << std::endl;

  // Existential: Internal and Output Signals
  out << "e ";
  for(int  i = FIRST_SIGNAL; i < m_signalnxt; i++)  out << compact(i) << ' ';
  out << '0' << std::endl;

  // Clauses
  for(int lit : m_clauses) {
    if(lit)  out << compact(lit) << ' ';
    else     out << '0' << std::endl;
  }
  out.flush();
}

Result Root::solve() {
  if(m_res != QUANTOR_RESULT_UNKNOWN)  return  m_res;

  auto const  compact = varCompactor();
  qbm::Quantor  q;
  std::cout << "using Quantor_" << q.version() << " / " << q.backend() << std::endl;

  q.scope(QUANTOR_EXISTENTIAL_VARIABLE_TYPE);
  for(int  i = FIRST_CONFIG; i < m_confignxt; i++)  q.add(compact(i));
  q.add(0);

  q.scope(QUANTOR_UNIVERSAL_VARIABLE_TYPE);
  for(int  i = FIRST_INPUT; i < m_inputnxt; i++)  q.add(compact(i));
  q.add(0);

  q.scope(QUANTOR_EXISTENTIAL_VARIABLE_TYPE);
  for(int  i = FIRST_SIGNAL; i < m_signalnxt; i++)  q.add(compact(i));
  q.add(0);

  for(int lit : m_clauses) q.add(lit? compact(lit) : 0);
  m_clauses.clear();

  m_res = q.sat();
  if(m_res) {
    int const *asgn = q.assignment();
    while(true) {
      int const  v = *asgn++;
      if(v == 0)  break;
      if(v > 0)  m_clauses.push_back(v+1);
    }
    std::sort(m_clauses.begin(), m_clauses.end());
  }
  return  m_res;
}

void Root::printConfig(std::ostream &out) const {
  class Printer : public Scope::Visitor {
    Root const   &m_root;
    std::ostream &m_out;
    std::string   m_path;

  public:
    Printer(Root const &root, std::ostream &out) : m_root(root), m_out(out) {}
    ~Printer() {}

  public:
    void visitConfig(std::string const &name, Bus const &bus) {
      std::stringstream  s;
      for(unsigned  i = bus.width(); i-- > 0; s << m_root.resolve(bus[i]));
      m_out << m_path << name << " = \"" << s.str() << "\";" << std::endl;
    }
    void visitChild(std::string const &name, Scope const &child) {
      std::string const  prev = m_path;
      m_path += child.name();
      child.accept(*this);
      m_path = prev;
    }
  } prn(*this, out);
  m_top.accept(prn);
}
